<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Ios 的架构模式（揭秘 Mvc，mvp，mvvm 和 Viper）</title>
  <meta name="description" content="记录在工作学习中的笔记，专注于分享移动开发领域高质量文章，努力做一个徘徊于牛A和牛C之间的人">
  <meta name="author" content="zhangyinglong">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="DemonHuner的技术博客">
  <meta name="twitter:description" content="记录在工作学习中的笔记，专注于分享移动开发领域高质量文章，努力做一个徘徊于牛A和牛C之间的人">

  <meta property="og:type" content="article">
  <meta property="og:title" content="DemonHuner的技术博客">
  <meta property="og:description" content="记录在工作学习中的笔记，专注于分享移动开发领域高质量文章，努力做一个徘徊于牛A和牛C之间的人">

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://github.com/zhangyinglong/DemonHunter//2016/iOS-%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E6%8F%AD%E7%A7%98-MVC-MVP-MVVM-%E5%92%8C-VIPER/">
  <link rel="alternate" type="application/rss+xml" title="DemonHuner的技术博客" href="/feed.xml">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>
  
<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of DemonHuner的技术博客">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">DemonHuner的技术博客</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">记录在工作学习中的笔记，专注于分享移动开发领域高质量文章，努力做一个徘徊于牛A和牛C之间的人</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="link to DemonHuner的技术博客 blog" class="blog-button">Blog</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
          
            
              <!-- Twitter -->
              <li class="navigation__item">
                <a href="http://twitter.com/zhangyinglong" title="@zhangyinglong on Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>
            

            
              <!-- Facebook -->
              <li class="navigation__item">
                <a href="http://fb.me/张应龙" title="张应龙 on Facebook" target="_blank">
                  <i class="icon icon-social-facebook"></i>
                  <span class="label">Facebook</span>
                </a>
              </li>
            

            
              <!-- LinkedIn -->
              <li class="navigation__item">
                <a href="https://www.linkedin.com/in/张应龙" title="张应龙 on LinkedIn" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">LinkedIn</span>
                </a>
              </li>
            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/zhangyinglong" title="zhangyinglong on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            
              <!-- Email -->
              <li class="navigation__item">
                <a href="mailto:zyl04401@gmail.com" title="Email zyl04401@gmail.com" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>
            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>
          
            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="18 Apr 2016" class="post-meta__date date">18 Apr 2016</time> &#8226; <span class="post-meta__tags">on </span>
    </div>
    <h1 class="post-title">Ios 的架构模式（揭秘 Mvc，mvp，mvvm 和 Viper）</h1>
  </header>

  <section class="post">
    <h4>序言</h4>

<p>之前看了一篇国外大牛<a href="https://medium.com/@borlov">Bohdan Orlov</a>写的关于 iOS 架构模式的文章，内容涉及目前 iOS 端诸多主流的模式，个人感觉文章写的很不错，收获匪浅，希望能够通过翻译原文的方式更好的体会一下，也分享给更多的人参考。原文地址<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.sdi54bown">在这里</a>，并附上相关<a href="http://slides.com/borlov/arch/fullscreen#/">PPT</a>，浏览原文可能需要科学上网。</p>

<h4>正文</h4>

<p>在 iOS 开发中使用 MVC 是否感觉很怪异？对 MVVM 感到有疑问？听说过 VIPER，但是又不确定它是否有价值？继续阅读本文，你将会找到这些问题的答案，如果没有找到满意的答案，请在评论中随便吐槽吧。本文将帮助你建立起关于 iOS 端架构模式的知识体系。我们先来简要地回顾一些主流的架构，并且从理论和一些小例子的实践上进行比较。</p>

<blockquote>
<p>注意：学习设计模式是进阶阶段，因此在阅读本文之前，假设你已有一定的基础，不会再询问如下的问题：  </p>

<p>1、谁应该持有网络请求，Model 还是 Controller？</p>

<p>2、如何给View的ViewModel传递Model？ </p>

<p>3、谁能创建一个VIPER模块：Router 还是 Presenter？</p>
</blockquote>

<h4>为什么要关心选择什么样的架构</h4>

<p>如果不关心架构，想象某天你调试一个巨大的类，里面有着数十个不同关联东西，你会发现几乎不可能定位问题点并修复bug。当然，你也很难去随心所欲地使用这个类，因为不了解类其中的一些重要细节。如果你在项目中已经遇到了这种场景，它可能是像这样的：</p>

<blockquote>
<p>1、这个类是UIViewController的子类</p>

<p>2、数据直接存储在UIViewController中</p>

<p>3、视图View没有任何操作</p>

<p>4、Model的数据结构设计很糟糕</p>

<p>5、没有单元测试覆盖</p>
</blockquote>

<p>即使你遵循了苹果指导意见并实现了<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">苹果的 MVC 模式</a>，这种情况还是可能会发生，不必觉得很难过。苹果的 MVC 有点问题，我们回头再说这件事情。让我们来定义一个好架构应该有的特征：</p>

<blockquote>
<p>1、严格划分，均衡分配实体间的角色和职责</p>

<p>2、可测性通常是第一特性（不要担心：好架构一定具有可测性）</p>

<p>3、便于使用，且维护成本低</p>
</blockquote>

<h5>为什么要划分</h5>

<p>当试图了解程序如何运行时，角色和职责划分能够让我们保持思路清晰。如果你的开发能力越强，你就越能理解复杂的事物。但是这种能力并不是线性增长的，会很快达到极限。因此降低复杂性的最简单办法是遵循<strong>单一责任原则</strong>，划分多个实体之间的职责。</p>

<h5>为什么要可测性</h5>

<p>对于那些由于添加新特性，或者一些正在重构中的错综复杂的类来说，开发人员应该感激出现失败的单元测试，因为这些失败的单元测试可以帮助开发人员尽快定位运行中出现的bug，而这些bug可能出现在用户的设备上，甚至需要花费数周才能修复。</p>

<h5>为什么要易用</h5>

<p>这不需要回答，但值得一提的是，最好的代码就是不用写代码，因此写的越少越不容易出错。这意味着想写少量代码的想法不仅仅是因为开发者的懒惰，而且你也不应当被一个更灵巧的解决方案所蒙蔽，而忽略了维护它的成本。</p>

<h4>MV(X)系列导论</h4>

<p>现在当我们要做架构设计时有很多种模式选择：</p>

<ul>
<li><strong><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a></strong></li>
<li><strong><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a></strong></li>
<li><strong><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">MVVM</a></strong></li>
<li><strong><a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a></strong></li>
</ul>

<p>前三者采用的都是把App中实体划分成3类：</p>

<ul>
<li><strong>Models</strong> - 负责持有数据，进行数据处理的数据访问层。设想一下<code>Person</code>，<code>PersonDataProvider</code>类。</li>
<li><strong>Views</strong> - 负责数据展现层（Graphical User Interface），在iOS端可认为所有以<code>UI</code>前缀的类。</li>
<li><strong>Controller/Presenter/ViewModel</strong> - 负责协调处理<strong>Models</strong>和<strong>Views</strong>之间的交互。</li>
</ul>

<p>通常用户操作视图会触发数据更新，数据的变更又会引起视图更新。这样的划分实体能让我们：</p>

<ul>
<li>更好的理解他们是如何工作的</li>
<li>复用他们（通常可复用的是<strong>Views</strong>和<strong>Models</strong>）</li>
<li>单独测试他们</li>
</ul>

<p>让我们开始学习<strong>MV(X)</strong>模式，稍后再说<strong>VIPER</strong>。</p>

<h5>一、MVC（Model-View-Controller）</h5>

<p>在讨论Apple版本的MVC之前，我们先来看看传统的MVC
<img src="http://upload-images.jianshu.io/upload_images/1200910-3885caafacea4fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Traditional MVC">
图示中，视图<strong>Views</strong>是无状态的，它只是当数据<strong>Models</strong>发生变化时，通过<strong>Controller</strong>控制简单地展现一下。设想当你点击网页上某个跳转链接时，整个网页就会重新加载。虽然在iOS应用程序中这种传统的MVC很容易实现，但这是没有意义的，因为架构上3类实体紧密的耦合在一起，每一类实体都要和其他两类产生关联，这会大大降低代码的可复用性。这不会是你想要的架构，由于以上原因，我们就不写这种MVC的典型例子了。</p>

<blockquote>
<p>传统的MVC不适合当前的iOS开发工作</p>
</blockquote>

<h5>Apple版的MVC</h5>

<p>Apple期望的<strong>Cocoa MVC</strong>：
<img src="http://upload-images.jianshu.io/upload_images/1200910-c61f640340ed8b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cocoa MVC">
控制器<strong>Controller</strong>是视图<strong>Views</strong>和数据<strong>Models</strong>之间的中介，它们之间不需要有关联。可复用性最低的控制器<strong>Controller</strong>，通常是可以接受的，因为我们必须有一个地方来放置那些不适合放在数据<strong>Models</strong>中的所有复杂业务逻辑。理论上，它看上去非常简单明了，你是不是感觉到有什么问题？甚至听到过有人叫 MVC 为重控制器模式。此外，对于 iOS 开发者来说，给控制器减轻负担已经成为一个重要的话题。为什么苹果会采用仅仅改进过一点点的传统 MVC 模式呢？实际上的<strong>Realistic Cocoa MVC</strong>：
<img src="http://upload-images.jianshu.io/upload_images/1200910-a32bf868aa34205a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Realistic Cocoa MVC">
<strong>Cocoa MVC</strong>鼓励你写重控制器是因为它们在<strong>Views</strong>的生命周期中相互依赖，以至于很难将它们分开。虽然你可能有办法把一些业务逻辑和数据转模型的工作放到<strong>Models</strong>中，但是对于分摊到<strong>Views</strong>上的工作却没有什么办法，大多数情况下，<strong>Views</strong>的所有功能就是给控制器<strong>Controller</strong>发送操作事件，而<strong>Controller</strong>最终会成为你可以想到所有东西的代理或者数据源，比如通常会负责发送或者取消网络请求等等。你经常会看到这样的代码：</p>
<div class="highlight"><pre><code class="language-" data-lang="">var userCell = tableView.dequeueReusableCellWithIdentifier("identifier") as UserCell
userCell.configureWithUser(user)
</code></pre></div>
<p>cell 作为一个视图<strong>Views</strong>直接通过<strong>Models</strong>进行配置，MVC 的原则被违反了，但这种情况一直在发生，大家也没觉得有什么错。如果你严格的遵守 MVC，那么你就需要通过<strong>Controller</strong>对 cell 进行配置，并且不把<strong>Models</strong>传进<strong>Views</strong>中，然而这将会更进一步地增加<strong>Controller</strong>的规模。</p>

<blockquote>
<p>把<strong>Cocoa MVC</strong>称作重控制器模式还是有一定道理的。</p>
</blockquote>

<p>问题直到需要进行单元测试了才会暴露出来（希望你的项目也一样）。由于<strong>Controller</strong>和<strong>Views</strong>紧紧的耦合在一起，单元测试变得很困难，因为你将不得不非常有想象力的去模拟<strong>Views</strong>的生命周期，写<strong>Controller</strong>测试代码时也必须尽可能把业务逻辑代码同<strong>Views</strong>的布局代码分离开。让我们来看一个简单的<code>playground</code>例子：</p>
<div class="highlight"><pre><code class="language-" data-lang="">import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

class GreetingViewController : UIViewController { // View + Controller
    var person: Person!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        let greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName
        self.greetingLabel.text = greeting
        
    }
    // layout code goes here
}
// Assembling of MVC
let model = Person(firstName: "David", lastName: "Blaine")
let view = GreetingViewController()
view.person = model;
</code></pre></div>
<blockquote>
<p>MVC架构可以在视图控制器中进行组装</p>
</blockquote>

<p>这段代码看上去不可测，对吧？我们可以把生成<code>greeting</code>字符串的代码封装到新的<code>GreetingModel</code>类中单独测试它。但是在不直接调用视图<code>UIView</code>相关方法（<code>viewDidLoad</code>，<code>didTapButton</code>这些方法可能会加载所有视图）的前提下，我们还是无法测试<code>GreetingViewController</code>内部任意的展现逻辑（虽然这个例子没有多少逻辑），这不利于单元测试。实际上，在一个模拟器（例如：iPhone 4S）上的测试并不能够保证在其他设备（例如：iPad）上也能运行良好。因此建议在单元测试中删除<code>Host Application</code>的配置，并且测试用例不要运行在模拟器上。</p>

<blockquote>
<p>视图和控制器之间的交互并不是真正的单元测试</p>
</blockquote>

<p>综上所述，<strong>Cocoa MVC</strong>似乎是一个相当糟糕的模式。让我们用文章开头提到的好架构特征来对它进行一个评估：</p>

<ul>
<li>划分 - <strong>View</strong>和<strong>Model</strong>确实是分离了，但是<strong>View</strong>和<strong>Controller</strong>还是紧紧地耦合在一起。</li>
<li>可测试性 - 由于划分的不好，你可能只能测试你的<strong>Model</strong>。</li>
<li>易用性 - 相比于其他模式代码量最小，此外门槛低，每个人都能熟练掌握，即使不是一个非常有经验的开发者也能进行维护。</li>
</ul>

<p>如果对于你的小项目，不打算投入很多时间去设计架构，也不打算投入太多成本去维护，那么<strong>Cocoa MVC</strong>是你要选择的模式。</p>

<blockquote>
<p>在开发速度上，<strong>Cocoa MVC</strong>是最好的架构模式。</p>
</blockquote>

<h5>二、MVP（Model-View-Presenter）</h5>

<p><strong>Cocoa MVC</strong>的演变
<img src="http://upload-images.jianshu.io/upload_images/1200910-9baeb421012b2c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Passive View variant of MVP">
看上去是不是很像<strong>Cocoa MVC</strong>？的确很像，只是名叫<strong>MVP</strong>（Passive View Variant）。稍等。。。这是否意味着<strong>MVP</strong>的实质就是<strong>Cocoa MVC</strong>呢？当然不是，因为你回想一下<strong>View</strong>和<strong>Controller</strong>紧紧耦合在一起的位置，在<strong>MVP</strong>中是<strong>Presenter</strong> ，它与视图控制器的生命周期没有任何关联，并且由于没有任何布局的代码，很容易模拟视图<strong>View</strong>。它的职责是更新<strong>View</strong>中的数据和状态。</p>

<blockquote>
<p>如果我告诉你<code>UIViewController</code>就是视图，会怎么样</p>
</blockquote>

<p>在<strong>MVP</strong>方面，<code>UIViewController</code>的子类实际上是视图而不是<strong>Presenter</strong>。这种差别提供了很好的可测性，但会降低一定的开发速度，因为你不得不手动管理数据和绑定事件。举个例子：</p>
<div class="highlight"><pre><code class="language-" data-lang="">import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

protocol GreetingView: class {
    func setGreeting(greeting: String)
}

protocol GreetingViewPresenter {
    init(view: GreetingView, person: Person)
    func showGreeting()
}

class GreetingPresenter : GreetingViewPresenter {
    unowned let view: GreetingView
    let person: Person
    required init(view: GreetingView, person: Person) {
        self.view = view
        self.person = person
    }
    func showGreeting() {
        let greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName
        self.view.setGreeting(greeting)
    }
}

class GreetingViewController : UIViewController, GreetingView {
    var presenter: GreetingViewPresenter!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        self.presenter.showGreeting()
    }
    
    func setGreeting(greeting: String) {
        self.greetingLabel.text = greeting
    }
    
    // layout code goes here
}
// Assembling of MVP
let model = Person(firstName: "David", lastName: "Blaine")
let view = GreetingViewController()
let presenter = GreetingPresenter(view: view, person: model)
view.presenter = presenter
</code></pre></div>
<h5>关于组合的重要说明</h5>

<p><strong>MVP</strong>是第一个揭示了实际上由3个独立分层会存在组合问题的模式。既然我们并不希望<strong>View</strong>和<strong>Model</strong>耦合，在视图控制器中（实际上是<strong>View</strong>）组装它们就是不正确的，因此我们需要在其他地方处理。例如，我们可以让App范围内的路由服务来负责处理View与View之间的展现。这个问题不仅<strong>MVP</strong>中存在，后面将要介绍的所有模式中也都存在。我们来看看<strong>MVP</strong>的特征：</p>

<ul>
<li>划分 - 大部分职责都被划分给了<strong>Presenter</strong>和<strong>Model</strong>，<strong>View</strong>没有任何职责（例子中的Model也没有职责）。</li>
<li>可测试性 - 很好，我们可以测试大部门业务逻辑，因为<strong>View</strong>无职责。</li>
<li>易用性 - 在我们那个的不切实际的例子中，代码量比<strong>MVC</strong>翻了一倍，但同时，<strong>MVP</strong>的设计思路非常清晰。</li>
</ul>

<blockquote>
<p>在iOS开发中使用<strong>MVP</strong>模式意味着良好的可测性和很多的代码量。</p>
</blockquote>

<h5>基于绑定和监控</h5>

<p>还有另外一种形式的<strong>MVP</strong>模式 — 带监控器的<strong>MVP</strong>。这种模式的特点包括直接绑定<strong>View</strong>和<strong>Model</strong>，同时<strong>Presenter</strong>（监控器）仍然控制着<strong>View</strong>上的操作事件，并能改变<strong>View</strong>的展现。
<img src="http://upload-images.jianshu.io/upload_images/1200910-03817db5db459ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Supervising Presenter variant of the MVP">
但正如我们之前认识到的，模糊不清的职责分配是不好的设计，<strong>View</strong>和<strong>Model</strong>也紧紧的耦合在一起。这种模式跟Cocoa桌面端程序开发相似。和传统的<strong>MVC</strong>模式一样，对于有缺陷的架构，我认为没有必要再举例。</p>

<h5>三、MVVM（Model-View-ViewModel）</h5>

<p><strong>MVVM</strong>是最新的<strong>MV(X)</strong>系列架构，我们希望它在设计之初就已经考虑到之前的<strong>MV(X)</strong>系列所面临的问题。从理论上来看，Model-View-ViewModel看起来不错。<strong>View</strong>和<strong>Model</strong>我们已经很熟悉了，但中间层换成了<strong>ViewModel</strong>。
<img src="http://upload-images.jianshu.io/upload_images/1200910-97a18a72a52ca888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVVM">
它和<strong>MVP</strong>模式很像：</p>

<ul>
<li>视图控制器划分成<strong>View</strong></li>
<li><strong>View</strong>和<strong>Model</strong>之间没有紧密的耦合</li>
</ul>

<p>此外，数据绑定的概念很像带监控器的<strong>MVP</strong>，不同的是这次绑定的是<strong>View</strong>和<strong>ViewModel</strong>，而不是<strong>View</strong>和<strong>Model</strong>。那么在实际的iOS开发中<strong>ViewModel</strong>是什么？从根本上来说，它是独立于<code>UIKit</code>能够展现你的<strong>View</strong>和状态。<strong>ViewModel</strong>可以调用<strong>Model</strong>来改变数据，也可以通过数据变更来更新自己，因为<strong>View</strong>和<strong>ViewModel</strong>进行了绑定，相应地也就能同步更新<strong>View</strong>。</p>

<h5>绑定</h5>

<p>在介绍<strong>MVP</strong>部分我简要地提到绑定的概念，但我们还是在这里讨论一下它。绑定来源于OS X开发环境，在iOS开发中没有。当然我们可以使用<code>KVO</code>和消息通知机制，但都不如绑定方便。因此，如果我们不想自己实现一套绑定机制，有两种选择：</p>

<ul>
<li>基于<code>KVO</code>的数据绑定库，比如<a href="https://github.com/Raizlabs/RZDataBinding">RZDataBinding</a>，<a href="https://github.com/SwiftBond/Bond">SwiftBond</a></li>
<li>全量级的<a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6">函数式响应编程框架</a>，比如<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>，<a href="https://github.com/ReactiveX/RxSwift/">RxSwift</a>，<a href="https://github.com/mxcl/PromiseKit">PromiseKit</a></li>
</ul>

<p>实际上，当你听到<strong>MVVM</strong>就会联想到<code>ReactiveCocoa</code>，反之亦然。虽然使用<code>ReactiveCocoa</code>框架可能是你很容易建立起基于绑定的<strong>MVVM</strong>，并且发挥出它的最大价值，但响应式框架有一个痛苦的现实：能力越大，责任也就越大。当你使用响应式框架的时候很容易就搞得乱七八糟，换句话说，如果出现bug，你将会花费大量的时间去调试bug，看看下面的调用堆栈图。
<img src="http://upload-images.jianshu.io/upload_images/1200910-66a0376d2e3269d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Reactive Call Stack"></p>

<p>在我们的简单例子中，无论是使用函数响应式框架，还是<code>KVO</code>都有点大材小用。我们换另外的方式，通过调用<code>showGreeting</code>方法来请求<strong>View Model</strong>更新<strong>View</strong>，使用<code>greetingDidChange</code>回调函数作为简单的属性。</p>
<div class="highlight"><pre><code class="language-" data-lang="">import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

protocol GreetingViewModelProtocol: class {
    var greeting: String? { get }
    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? { get set } // function to call when greeting did change
    init(person: Person)
    func showGreeting()
}

class GreetingViewModel : GreetingViewModelProtocol {
    let person: Person
    var greeting: String? {
        didSet {
            self.greetingDidChange?(self)
        }
    }
    var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())?
    required init(person: Person) {
        self.person = person
    }
    func showGreeting() {
        self.greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName
    }
}

class GreetingViewController : UIViewController {
    var viewModel: GreetingViewModelProtocol! {
        didSet {
            self.viewModel.greetingDidChange = { [unowned self] viewModel in
                self.greetingLabel.text = viewModel.greeting
            }
        }
    }
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self.viewModel, action: "showGreeting", forControlEvents: .TouchUpInside)
    }
    // layout code goes here
}
// Assembling of MVVM
let model = Person(firstName: "David", lastName: "Blaine")
let viewModel = GreetingViewModel(person: model)
let view = GreetingViewController()
view.viewModel = viewModel
</code></pre></div>
<p>再来看看<strong>MVVM</strong>的特征：</p>

<ul>
<li>划分 - 在我们这个小例子中看到的不是很清晰，但实际上，<strong>MVVM</strong>中的<strong>View</strong>承担了比<strong>MVP</strong>要多的职责。首先它需要绑定<strong>ViewModel</strong>来更新状态，其次它需要传递所有的事件消息而不需要更新事件的提供者。</li>
<li>可测试性 - <strong>ViewModel</strong>并不持有<strong>View</strong>，这让我们很容易测试它。<strong>View</strong>也可以测试，但它依赖<code>UIKit</code>通常会忽略掉。</li>
<li>易用性 - 代码量和<strong>MVP</strong>一样多，但真实的App开发中如果采用绑定机制，去替换那些传递事件和手动更新的代码，会减少很多代码量。</li>
</ul>

<blockquote>
<p><strong>MVVM</strong>是非常吸引人的，因为它结合了前面提及的几种模式的优点，此外使用绑定机制不需要编写额外的视图更新代码，并且保持了良好的可测试性。</p>
</blockquote>

<h5>四、VIPER（View-Interactor-Presenter-Entity-Routing）</h5>

<p>从搭积木中领悟的iOS设计</p>

<p><strong>VIPER</strong>是本文最后一个介绍的架构模式，它很有趣，不属于<strong>MV(X) **系列的扩展。到目前为止，你必须意识到一个好的设计一定有细粒度的职责划分。</strong>VIPER**从另一个不同的角度进行了职责划分，这次我们分为5层：
<img src="http://upload-images.jianshu.io/upload_images/1200910-be9d6cfc80104b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VIPER"></p>

<ul>
<li><strong>交互器</strong>：包含与数据（<strong>实体</strong>）或网络相关的业务逻辑，比如从服务器获取一些新的数据实体，为了这些目的，你会使用一些<code>Services</code>和<code>Managers</code>，它们并不被认为属于<strong>VIPER</strong>中的一部分，更确切地说它们是一种额外的依赖。</li>
<li><strong>展示器</strong>：包含一些与UI相关（<code>UIKit</code>除外）的业务逻辑，通过交互器调用方法。</li>
<li><strong>实体</strong>：纯粹的数据对象，不包含数据访问层，因为这是交互器的职责。</li>
<li><strong>路由器</strong>：负责<strong>VIPER</strong>模块之间的切换。从根本上说，粒度划分方式，<strong>VIPER</strong>模块可以用来设计一个场景的功能，也可以用来设计应用中的一个完整用户故事—比如身份验证，是由一个场景或者若干场景组成，应该用多大的积木块来搭乐高玩具，完全取决于你。</li>
</ul>

<p>同<strong>MV(X)</strong>系列对比，我们会发现在职责划分上有一些不同点：</p>

<ul>
<li><strong>Model</strong> — 数据交互逻辑被转移到了交互器<strong>Interactor</strong>中，<strong>Entities</strong>只有纯粹的数据结构。</li>
<li><strong>Controller/Presenter/ViewModel</strong>中的UI展现职责转移到了交互器<strong>Interactor</strong>中，但它没有更改数据的能力。</li>
<li><strong>VIPER</strong>是第一个明确提出地址导航职责应该由路由器<strong>Router</strong>来解决。</li>
</ul>

<blockquote>
<p>在iOS应用中找到一种合适的路由方式是一个挑战，<strong>MV(X)</strong>系列模式都没有定位到这个问题。</p>
</blockquote>

<p>下面的<strong>VIPER</strong>例子中没有涉及到模块之间的路由或交互，当然在<strong>MV(X)</strong>系列模式中也根本没有涉及。</p>
<div class="highlight"><pre><code class="language-" data-lang="">import UIKit

struct Person { // Entity (usually more complex e.g. NSManagedObject)
    let firstName: String
    let lastName: String
}

struct GreetingData { // Transport data structure (not Entity)
    let greeting: String
    let subject: String
}

protocol GreetingProvider {
    func provideGreetingData()
}

protocol GreetingOutput: class {
    func receiveGreetingData(greetingData: GreetingData)
}

class GreetingInteractor : GreetingProvider {
    weak var output: GreetingOutput!
    
    func provideGreetingData() {
        let person = Person(firstName: "David", lastName: "Blaine") // usually comes from data access layer
        let subject = person.firstName + " " + person.lastName
        let greeting = GreetingData(greeting: "Hello", subject: subject)
        self.output.receiveGreetingData(greeting)
    }
}

protocol GreetingViewEventHandler {
    func didTapShowGreetingButton()
}

protocol GreetingView: class {
    func setGreeting(greeting: String)
}

class GreetingPresenter : GreetingOutput, GreetingViewEventHandler {
    weak var view: GreetingView!
    var greetingProvider: GreetingProvider!
    
    func didTapShowGreetingButton() {
        self.greetingProvider.provideGreetingData()
    }
    
    func receiveGreetingData(greetingData: GreetingData) {
        let greeting = greetingData.greeting + " " + greetingData.subject
        self.view.setGreeting(greeting)
    }
}

class GreetingViewController : UIViewController, GreetingView {
    var eventHandler: GreetingViewEventHandler!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        self.eventHandler.didTapShowGreetingButton()
    }
    
    func setGreeting(greeting: String) {
        self.greetingLabel.text = greeting
    }
    
    // layout code goes here
}
// Assembling of VIPER module, without Router
let view = GreetingViewController()
let presenter = GreetingPresenter()
let interactor = GreetingInteractor()
view.eventHandler = presenter
presenter.view = view
presenter.greetingProvider = interactor
interactor.output = presenter
</code></pre></div>
<p>让我们再来看看<strong>VIPER</strong>的特征：
* 划分 - 毫无疑问，<strong>VIPER</strong>在职责划分上是最好的。
* 可测试性 - 毫无悬念，好的职责划分必然有好的可测性。
* 易用性 - 由于上述两个特征你就可以猜测到代码维护性成本很高，你不得不编写大量的接口类来完成很小的职责。</p>

<h4>总结</h4>

<p>我们已经从头到尾地了解了几种架构模式，希望你能从中找到那些曾经困扰你很久的问题的答案。但我毫不怀疑，你已经意识到了没有什么银色子弹，选择什么样的架构设计是特定场景下权衡各种因素之后的结果。因此，在同一个app中就会出现混合架构设计。比如：一开始使用<strong>MVC</strong>，然后你发现有一些特殊场景如果使用<strong>MVC</strong>将会难以维护，这时你可以仅对这个场景使用<strong>MVVM</strong>模式，没必要去重构那些<strong>MVC</strong>架构执行的很好的模块。<strong>MV(X)</strong>系列是互相兼容的。</p>

<blockquote>
<p>Make everything as simple as possible, but not simpler. -- Albert Einstein</p>
</blockquote>

  </section>
  
</article>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2016 zhangyinglong. All rights reserved.</span>
</footer> 

<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js"></script>

    </div>
  </body>
</html>