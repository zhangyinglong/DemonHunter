<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DemonHuner的技术博客</title>
    <description>记录在工作学习中的笔记，专注于分享移动开发领域高质量文章，努力做一个徘徊于牛A和牛C之间的人</description>
    <link>https://github.com/zhangyinglong/DemonHunter//</link>
    <atom:link href="https://github.com/zhangyinglong/DemonHunter//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 19 Apr 2016 00:26:38 +0800</pubDate>
    <lastBuildDate>Tue, 19 Apr 2016 00:26:38 +0800</lastBuildDate>
    <generator>Jekyll v3.0.2</generator>
    
      <item>
        <title>Ios 的架构模式（揭秘 Mvc，mvp，mvvm 和 Viper）</title>
        <description>&lt;h4&gt;序言&lt;/h4&gt;

&lt;p&gt;之前看了一篇国外大牛&lt;a href=&quot;https://medium.com/@borlov&quot;&gt;Bohdan Orlov&lt;/a&gt;写的关于 iOS 架构模式的文章，内容涉及目前 iOS 端诸多主流的模式，个人感觉文章写的很不错，收获匪浅，希望能够通过翻译原文的方式更好的体会一下，也分享给更多的人参考。原文地址&lt;a href=&quot;https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.sdi54bown&quot;&gt;在这里&lt;/a&gt;，并附上相关&lt;a href=&quot;http://slides.com/borlov/arch/fullscreen#/&quot;&gt;PPT&lt;/a&gt;，浏览原文可能需要科学上网。&lt;/p&gt;

&lt;h4&gt;正文&lt;/h4&gt;

&lt;p&gt;在 iOS 开发中使用 MVC 是否感觉很怪异？对 MVVM 感到有疑问？听说过 VIPER，但是又不确定它是否有价值？继续阅读本文，你将会找到这些问题的答案，如果没有找到满意的答案，请在评论中随便吐槽吧。本文将帮助你建立起关于 iOS 端架构模式的知识体系。我们先来简要地回顾一些主流的架构，并且从理论和一些小例子的实践上进行比较。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：学习设计模式是进阶阶段，因此在阅读本文之前，假设你已有一定的基础，不会再询问如下的问题：  &lt;/p&gt;

&lt;p&gt;1、谁应该持有网络请求，Model 还是 Controller？&lt;/p&gt;

&lt;p&gt;2、如何给View的ViewModel传递Model？ &lt;/p&gt;

&lt;p&gt;3、谁能创建一个VIPER模块：Router 还是 Presenter？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4&gt;为什么要关心选择什么样的架构&lt;/h4&gt;

&lt;p&gt;如果不关心架构，想象某天你调试一个巨大的类，里面有着数十个不同关联东西，你会发现几乎不可能定位问题点并修复bug。当然，你也很难去随心所欲地使用这个类，因为不了解类其中的一些重要细节。如果你在项目中已经遇到了这种场景，它可能是像这样的：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1、这个类是UIViewController的子类&lt;/p&gt;

&lt;p&gt;2、数据直接存储在UIViewController中&lt;/p&gt;

&lt;p&gt;3、视图View没有任何操作&lt;/p&gt;

&lt;p&gt;4、Model的数据结构设计很糟糕&lt;/p&gt;

&lt;p&gt;5、没有单元测试覆盖&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即使你遵循了苹果指导意见并实现了&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html&quot;&gt;苹果的 MVC 模式&lt;/a&gt;，这种情况还是可能会发生，不必觉得很难过。苹果的 MVC 有点问题，我们回头再说这件事情。让我们来定义一个好架构应该有的特征：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1、严格划分，均衡分配实体间的角色和职责&lt;/p&gt;

&lt;p&gt;2、可测性通常是第一特性（不要担心：好架构一定具有可测性）&lt;/p&gt;

&lt;p&gt;3、便于使用，且维护成本低&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;为什么要划分&lt;/h5&gt;

&lt;p&gt;当试图了解程序如何运行时，角色和职责划分能够让我们保持思路清晰。如果你的开发能力越强，你就越能理解复杂的事物。但是这种能力并不是线性增长的，会很快达到极限。因此降低复杂性的最简单办法是遵循&lt;strong&gt;单一责任原则&lt;/strong&gt;，划分多个实体之间的职责。&lt;/p&gt;

&lt;h5&gt;为什么要可测性&lt;/h5&gt;

&lt;p&gt;对于那些由于添加新特性，或者一些正在重构中的错综复杂的类来说，开发人员应该感激出现失败的单元测试，因为这些失败的单元测试可以帮助开发人员尽快定位运行中出现的bug，而这些bug可能出现在用户的设备上，甚至需要花费数周才能修复。&lt;/p&gt;

&lt;h5&gt;为什么要易用&lt;/h5&gt;

&lt;p&gt;这不需要回答，但值得一提的是，最好的代码就是不用写代码，因此写的越少越不容易出错。这意味着想写少量代码的想法不仅仅是因为开发者的懒惰，而且你也不应当被一个更灵巧的解决方案所蒙蔽，而忽略了维护它的成本。&lt;/p&gt;

&lt;h4&gt;MV(X)系列导论&lt;/h4&gt;

&lt;p&gt;现在当我们要做架构设计时有很多种模式选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller&quot;&gt;MVC&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter&quot;&gt;MVP&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel&quot;&gt;MVVM&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.objc.io/issues/13-architecture/viper/&quot;&gt;VIPER&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前三者采用的都是把App中实体划分成3类：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Models&lt;/strong&gt; - 负责持有数据，进行数据处理的数据访问层。设想一下&lt;code&gt;Person&lt;/code&gt;，&lt;code&gt;PersonDataProvider&lt;/code&gt;类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Views&lt;/strong&gt; - 负责数据展现层（Graphical User Interface），在iOS端可认为所有以&lt;code&gt;UI&lt;/code&gt;前缀的类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller/Presenter/ViewModel&lt;/strong&gt; - 负责协调处理&lt;strong&gt;Models&lt;/strong&gt;和&lt;strong&gt;Views&lt;/strong&gt;之间的交互。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常用户操作视图会触发数据更新，数据的变更又会引起视图更新。这样的划分实体能让我们：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更好的理解他们是如何工作的&lt;/li&gt;
&lt;li&gt;复用他们（通常可复用的是&lt;strong&gt;Views&lt;/strong&gt;和&lt;strong&gt;Models&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;单独测试他们&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;让我们开始学习&lt;strong&gt;MV(X)&lt;/strong&gt;模式，稍后再说&lt;strong&gt;VIPER&lt;/strong&gt;。&lt;/p&gt;

&lt;h5&gt;一、MVC（Model-View-Controller）&lt;/h5&gt;

&lt;p&gt;在讨论Apple版本的MVC之前，我们先来看看传统的MVC
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-3885caafacea4fe0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Traditional MVC&quot;&gt;
图示中，视图&lt;strong&gt;Views&lt;/strong&gt;是无状态的，它只是当数据&lt;strong&gt;Models&lt;/strong&gt;发生变化时，通过&lt;strong&gt;Controller&lt;/strong&gt;控制简单地展现一下。设想当你点击网页上某个跳转链接时，整个网页就会重新加载。虽然在iOS应用程序中这种传统的MVC很容易实现，但这是没有意义的，因为架构上3类实体紧密的耦合在一起，每一类实体都要和其他两类产生关联，这会大大降低代码的可复用性。这不会是你想要的架构，由于以上原因，我们就不写这种MVC的典型例子了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;传统的MVC不适合当前的iOS开发工作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;Apple版的MVC&lt;/h5&gt;

&lt;p&gt;Apple期望的&lt;strong&gt;Cocoa MVC&lt;/strong&gt;：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-c61f640340ed8b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Cocoa MVC&quot;&gt;
控制器&lt;strong&gt;Controller&lt;/strong&gt;是视图&lt;strong&gt;Views&lt;/strong&gt;和数据&lt;strong&gt;Models&lt;/strong&gt;之间的中介，它们之间不需要有关联。可复用性最低的控制器&lt;strong&gt;Controller&lt;/strong&gt;，通常是可以接受的，因为我们必须有一个地方来放置那些不适合放在数据&lt;strong&gt;Models&lt;/strong&gt;中的所有复杂业务逻辑。理论上，它看上去非常简单明了，你是不是感觉到有什么问题？甚至听到过有人叫 MVC 为重控制器模式。此外，对于 iOS 开发者来说，给控制器减轻负担已经成为一个重要的话题。为什么苹果会采用仅仅改进过一点点的传统 MVC 模式呢？实际上的&lt;strong&gt;Realistic Cocoa MVC&lt;/strong&gt;：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-a32bf868aa34205a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Realistic Cocoa MVC&quot;&gt;
&lt;strong&gt;Cocoa MVC&lt;/strong&gt;鼓励你写重控制器是因为它们在&lt;strong&gt;Views&lt;/strong&gt;的生命周期中相互依赖，以至于很难将它们分开。虽然你可能有办法把一些业务逻辑和数据转模型的工作放到&lt;strong&gt;Models&lt;/strong&gt;中，但是对于分摊到&lt;strong&gt;Views&lt;/strong&gt;上的工作却没有什么办法，大多数情况下，&lt;strong&gt;Views&lt;/strong&gt;的所有功能就是给控制器&lt;strong&gt;Controller&lt;/strong&gt;发送操作事件，而&lt;strong&gt;Controller&lt;/strong&gt;最终会成为你可以想到所有东西的代理或者数据源，比如通常会负责发送或者取消网络请求等等。你经常会看到这样的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;var userCell = tableView.dequeueReusableCellWithIdentifier(&quot;identifier&quot;) as UserCell
userCell.configureWithUser(user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;cell 作为一个视图&lt;strong&gt;Views&lt;/strong&gt;直接通过&lt;strong&gt;Models&lt;/strong&gt;进行配置，MVC 的原则被违反了，但这种情况一直在发生，大家也没觉得有什么错。如果你严格的遵守 MVC，那么你就需要通过&lt;strong&gt;Controller&lt;/strong&gt;对 cell 进行配置，并且不把&lt;strong&gt;Models&lt;/strong&gt;传进&lt;strong&gt;Views&lt;/strong&gt;中，然而这将会更进一步地增加&lt;strong&gt;Controller&lt;/strong&gt;的规模。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;把&lt;strong&gt;Cocoa MVC&lt;/strong&gt;称作重控制器模式还是有一定道理的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;问题直到需要进行单元测试了才会暴露出来（希望你的项目也一样）。由于&lt;strong&gt;Controller&lt;/strong&gt;和&lt;strong&gt;Views&lt;/strong&gt;紧紧的耦合在一起，单元测试变得很困难，因为你将不得不非常有想象力的去模拟&lt;strong&gt;Views&lt;/strong&gt;的生命周期，写&lt;strong&gt;Controller&lt;/strong&gt;测试代码时也必须尽可能把业务逻辑代码同&lt;strong&gt;Views&lt;/strong&gt;的布局代码分离开。让我们来看一个简单的&lt;code&gt;playground&lt;/code&gt;例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

class GreetingViewController : UIViewController { // View + Controller
    var person: Person!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        let greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName
        self.greetingLabel.text = greeting
        
    }
    // layout code goes here
}
// Assembling of MVC
let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)
let view = GreetingViewController()
view.person = model;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;MVC架构可以在视图控制器中进行组装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这段代码看上去不可测，对吧？我们可以把生成&lt;code&gt;greeting&lt;/code&gt;字符串的代码封装到新的&lt;code&gt;GreetingModel&lt;/code&gt;类中单独测试它。但是在不直接调用视图&lt;code&gt;UIView&lt;/code&gt;相关方法（&lt;code&gt;viewDidLoad&lt;/code&gt;，&lt;code&gt;didTapButton&lt;/code&gt;这些方法可能会加载所有视图）的前提下，我们还是无法测试&lt;code&gt;GreetingViewController&lt;/code&gt;内部任意的展现逻辑（虽然这个例子没有多少逻辑），这不利于单元测试。实际上，在一个模拟器（例如：iPhone 4S）上的测试并不能够保证在其他设备（例如：iPad）上也能运行良好。因此建议在单元测试中删除&lt;code&gt;Host Application&lt;/code&gt;的配置，并且测试用例不要运行在模拟器上。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;视图和控制器之间的交互并不是真正的单元测试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;综上所述，&lt;strong&gt;Cocoa MVC&lt;/strong&gt;似乎是一个相当糟糕的模式。让我们用文章开头提到的好架构特征来对它进行一个评估：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;划分 - &lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;确实是分离了，但是&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Controller&lt;/strong&gt;还是紧紧地耦合在一起。&lt;/li&gt;
&lt;li&gt;可测试性 - 由于划分的不好，你可能只能测试你的&lt;strong&gt;Model&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;易用性 - 相比于其他模式代码量最小，此外门槛低，每个人都能熟练掌握，即使不是一个非常有经验的开发者也能进行维护。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果对于你的小项目，不打算投入很多时间去设计架构，也不打算投入太多成本去维护，那么&lt;strong&gt;Cocoa MVC&lt;/strong&gt;是你要选择的模式。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在开发速度上，&lt;strong&gt;Cocoa MVC&lt;/strong&gt;是最好的架构模式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;二、MVP（Model-View-Presenter）&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Cocoa MVC&lt;/strong&gt;的演变
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-9baeb421012b2c2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Passive View variant of MVP&quot;&gt;
看上去是不是很像&lt;strong&gt;Cocoa MVC&lt;/strong&gt;？的确很像，只是名叫&lt;strong&gt;MVP&lt;/strong&gt;（Passive View Variant）。稍等。。。这是否意味着&lt;strong&gt;MVP&lt;/strong&gt;的实质就是&lt;strong&gt;Cocoa MVC&lt;/strong&gt;呢？当然不是，因为你回想一下&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Controller&lt;/strong&gt;紧紧耦合在一起的位置，在&lt;strong&gt;MVP&lt;/strong&gt;中是&lt;strong&gt;Presenter&lt;/strong&gt; ，它与视图控制器的生命周期没有任何关联，并且由于没有任何布局的代码，很容易模拟视图&lt;strong&gt;View&lt;/strong&gt;。它的职责是更新&lt;strong&gt;View&lt;/strong&gt;中的数据和状态。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果我告诉你&lt;code&gt;UIViewController&lt;/code&gt;就是视图，会怎么样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在&lt;strong&gt;MVP&lt;/strong&gt;方面，&lt;code&gt;UIViewController&lt;/code&gt;的子类实际上是视图而不是&lt;strong&gt;Presenter&lt;/strong&gt;。这种差别提供了很好的可测性，但会降低一定的开发速度，因为你不得不手动管理数据和绑定事件。举个例子：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

protocol GreetingView: class {
    func setGreeting(greeting: String)
}

protocol GreetingViewPresenter {
    init(view: GreetingView, person: Person)
    func showGreeting()
}

class GreetingPresenter : GreetingViewPresenter {
    unowned let view: GreetingView
    let person: Person
    required init(view: GreetingView, person: Person) {
        self.view = view
        self.person = person
    }
    func showGreeting() {
        let greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName
        self.view.setGreeting(greeting)
    }
}

class GreetingViewController : UIViewController, GreetingView {
    var presenter: GreetingViewPresenter!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        self.presenter.showGreeting()
    }
    
    func setGreeting(greeting: String) {
        self.greetingLabel.text = greeting
    }
    
    // layout code goes here
}
// Assembling of MVP
let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)
let view = GreetingViewController()
let presenter = GreetingPresenter(view: view, person: model)
view.presenter = presenter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;关于组合的重要说明&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;MVP&lt;/strong&gt;是第一个揭示了实际上由3个独立分层会存在组合问题的模式。既然我们并不希望&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;耦合，在视图控制器中（实际上是&lt;strong&gt;View&lt;/strong&gt;）组装它们就是不正确的，因此我们需要在其他地方处理。例如，我们可以让App范围内的路由服务来负责处理View与View之间的展现。这个问题不仅&lt;strong&gt;MVP&lt;/strong&gt;中存在，后面将要介绍的所有模式中也都存在。我们来看看&lt;strong&gt;MVP&lt;/strong&gt;的特征：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;划分 - 大部分职责都被划分给了&lt;strong&gt;Presenter&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;，&lt;strong&gt;View&lt;/strong&gt;没有任何职责（例子中的Model也没有职责）。&lt;/li&gt;
&lt;li&gt;可测试性 - 很好，我们可以测试大部门业务逻辑，因为&lt;strong&gt;View&lt;/strong&gt;无职责。&lt;/li&gt;
&lt;li&gt;易用性 - 在我们那个的不切实际的例子中，代码量比&lt;strong&gt;MVC&lt;/strong&gt;翻了一倍，但同时，&lt;strong&gt;MVP&lt;/strong&gt;的设计思路非常清晰。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;在iOS开发中使用&lt;strong&gt;MVP&lt;/strong&gt;模式意味着良好的可测性和很多的代码量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;基于绑定和监控&lt;/h5&gt;

&lt;p&gt;还有另外一种形式的&lt;strong&gt;MVP&lt;/strong&gt;模式 — 带监控器的&lt;strong&gt;MVP&lt;/strong&gt;。这种模式的特点包括直接绑定&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;，同时&lt;strong&gt;Presenter&lt;/strong&gt;（监控器）仍然控制着&lt;strong&gt;View&lt;/strong&gt;上的操作事件，并能改变&lt;strong&gt;View&lt;/strong&gt;的展现。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-03817db5db459ef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Supervising Presenter variant of the MVP&quot;&gt;
但正如我们之前认识到的，模糊不清的职责分配是不好的设计，&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;也紧紧的耦合在一起。这种模式跟Cocoa桌面端程序开发相似。和传统的&lt;strong&gt;MVC&lt;/strong&gt;模式一样，对于有缺陷的架构，我认为没有必要再举例。&lt;/p&gt;

&lt;h5&gt;三、MVVM（Model-View-ViewModel）&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;MVVM&lt;/strong&gt;是最新的&lt;strong&gt;MV(X)&lt;/strong&gt;系列架构，我们希望它在设计之初就已经考虑到之前的&lt;strong&gt;MV(X)&lt;/strong&gt;系列所面临的问题。从理论上来看，Model-View-ViewModel看起来不错。&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;我们已经很熟悉了，但中间层换成了&lt;strong&gt;ViewModel&lt;/strong&gt;。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-97a18a72a52ca888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MVVM&quot;&gt;
它和&lt;strong&gt;MVP&lt;/strong&gt;模式很像：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;视图控制器划分成&lt;strong&gt;View&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;之间没有紧密的耦合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，数据绑定的概念很像带监控器的&lt;strong&gt;MVP&lt;/strong&gt;，不同的是这次绑定的是&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;ViewModel&lt;/strong&gt;，而不是&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;Model&lt;/strong&gt;。那么在实际的iOS开发中&lt;strong&gt;ViewModel&lt;/strong&gt;是什么？从根本上来说，它是独立于&lt;code&gt;UIKit&lt;/code&gt;能够展现你的&lt;strong&gt;View&lt;/strong&gt;和状态。&lt;strong&gt;ViewModel&lt;/strong&gt;可以调用&lt;strong&gt;Model&lt;/strong&gt;来改变数据，也可以通过数据变更来更新自己，因为&lt;strong&gt;View&lt;/strong&gt;和&lt;strong&gt;ViewModel&lt;/strong&gt;进行了绑定，相应地也就能同步更新&lt;strong&gt;View&lt;/strong&gt;。&lt;/p&gt;

&lt;h5&gt;绑定&lt;/h5&gt;

&lt;p&gt;在介绍&lt;strong&gt;MVP&lt;/strong&gt;部分我简要地提到绑定的概念，但我们还是在这里讨论一下它。绑定来源于OS X开发环境，在iOS开发中没有。当然我们可以使用&lt;code&gt;KVO&lt;/code&gt;和消息通知机制，但都不如绑定方便。因此，如果我们不想自己实现一套绑定机制，有两种选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;基于&lt;code&gt;KVO&lt;/code&gt;的数据绑定库，比如&lt;a href=&quot;https://github.com/Raizlabs/RZDataBinding&quot;&gt;RZDataBinding&lt;/a&gt;，&lt;a href=&quot;https://github.com/SwiftBond/Bond&quot;&gt;SwiftBond&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;全量级的&lt;a href=&quot;https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6&quot;&gt;函数式响应编程框架&lt;/a&gt;，比如&lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa&lt;/a&gt;，&lt;a href=&quot;https://github.com/ReactiveX/RxSwift/&quot;&gt;RxSwift&lt;/a&gt;，&lt;a href=&quot;https://github.com/mxcl/PromiseKit&quot;&gt;PromiseKit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上，当你听到&lt;strong&gt;MVVM&lt;/strong&gt;就会联想到&lt;code&gt;ReactiveCocoa&lt;/code&gt;，反之亦然。虽然使用&lt;code&gt;ReactiveCocoa&lt;/code&gt;框架可能是你很容易建立起基于绑定的&lt;strong&gt;MVVM&lt;/strong&gt;，并且发挥出它的最大价值，但响应式框架有一个痛苦的现实：能力越大，责任也就越大。当你使用响应式框架的时候很容易就搞得乱七八糟，换句话说，如果出现bug，你将会花费大量的时间去调试bug，看看下面的调用堆栈图。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-66a0376d2e3269d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Reactive Call Stack&quot;&gt;&lt;/p&gt;

&lt;p&gt;在我们的简单例子中，无论是使用函数响应式框架，还是&lt;code&gt;KVO&lt;/code&gt;都有点大材小用。我们换另外的方式，通过调用&lt;code&gt;showGreeting&lt;/code&gt;方法来请求&lt;strong&gt;View Model&lt;/strong&gt;更新&lt;strong&gt;View&lt;/strong&gt;，使用&lt;code&gt;greetingDidChange&lt;/code&gt;回调函数作为简单的属性。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;import UIKit

struct Person { // Model
    let firstName: String
    let lastName: String
}

protocol GreetingViewModelProtocol: class {
    var greeting: String? { get }
    var greetingDidChange: ((GreetingViewModelProtocol) -&amp;gt; ())? { get set } // function to call when greeting did change
    init(person: Person)
    func showGreeting()
}

class GreetingViewModel : GreetingViewModelProtocol {
    let person: Person
    var greeting: String? {
        didSet {
            self.greetingDidChange?(self)
        }
    }
    var greetingDidChange: ((GreetingViewModelProtocol) -&amp;gt; ())?
    required init(person: Person) {
        self.person = person
    }
    func showGreeting() {
        self.greeting = &quot;Hello&quot; + &quot; &quot; + self.person.firstName + &quot; &quot; + self.person.lastName
    }
}

class GreetingViewController : UIViewController {
    var viewModel: GreetingViewModelProtocol! {
        didSet {
            self.viewModel.greetingDidChange = { [unowned self] viewModel in
                self.greetingLabel.text = viewModel.greeting
            }
        }
    }
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self.viewModel, action: &quot;showGreeting&quot;, forControlEvents: .TouchUpInside)
    }
    // layout code goes here
}
// Assembling of MVVM
let model = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;)
let viewModel = GreetingViewModel(person: model)
let view = GreetingViewController()
view.viewModel = viewModel
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看&lt;strong&gt;MVVM&lt;/strong&gt;的特征：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;划分 - 在我们这个小例子中看到的不是很清晰，但实际上，&lt;strong&gt;MVVM&lt;/strong&gt;中的&lt;strong&gt;View&lt;/strong&gt;承担了比&lt;strong&gt;MVP&lt;/strong&gt;要多的职责。首先它需要绑定&lt;strong&gt;ViewModel&lt;/strong&gt;来更新状态，其次它需要传递所有的事件消息而不需要更新事件的提供者。&lt;/li&gt;
&lt;li&gt;可测试性 - &lt;strong&gt;ViewModel&lt;/strong&gt;并不持有&lt;strong&gt;View&lt;/strong&gt;，这让我们很容易测试它。&lt;strong&gt;View&lt;/strong&gt;也可以测试，但它依赖&lt;code&gt;UIKit&lt;/code&gt;通常会忽略掉。&lt;/li&gt;
&lt;li&gt;易用性 - 代码量和&lt;strong&gt;MVP&lt;/strong&gt;一样多，但真实的App开发中如果采用绑定机制，去替换那些传递事件和手动更新的代码，会减少很多代码量。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MVVM&lt;/strong&gt;是非常吸引人的，因为它结合了前面提及的几种模式的优点，此外使用绑定机制不需要编写额外的视图更新代码，并且保持了良好的可测试性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5&gt;四、VIPER（View-Interactor-Presenter-Entity-Routing）&lt;/h5&gt;

&lt;p&gt;从搭积木中领悟的iOS设计&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VIPER&lt;/strong&gt;是本文最后一个介绍的架构模式，它很有趣，不属于&lt;strong&gt;MV(X) **系列的扩展。到目前为止，你必须意识到一个好的设计一定有细粒度的职责划分。&lt;/strong&gt;VIPER**从另一个不同的角度进行了职责划分，这次我们分为5层：
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-be9d6cfc80104b57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;VIPER&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;交互器&lt;/strong&gt;：包含与数据（&lt;strong&gt;实体&lt;/strong&gt;）或网络相关的业务逻辑，比如从服务器获取一些新的数据实体，为了这些目的，你会使用一些&lt;code&gt;Services&lt;/code&gt;和&lt;code&gt;Managers&lt;/code&gt;，它们并不被认为属于&lt;strong&gt;VIPER&lt;/strong&gt;中的一部分，更确切地说它们是一种额外的依赖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;展示器&lt;/strong&gt;：包含一些与UI相关（&lt;code&gt;UIKit&lt;/code&gt;除外）的业务逻辑，通过交互器调用方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实体&lt;/strong&gt;：纯粹的数据对象，不包含数据访问层，因为这是交互器的职责。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由器&lt;/strong&gt;：负责&lt;strong&gt;VIPER&lt;/strong&gt;模块之间的切换。从根本上说，粒度划分方式，&lt;strong&gt;VIPER&lt;/strong&gt;模块可以用来设计一个场景的功能，也可以用来设计应用中的一个完整用户故事—比如身份验证，是由一个场景或者若干场景组成，应该用多大的积木块来搭乐高玩具，完全取决于你。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同&lt;strong&gt;MV(X)&lt;/strong&gt;系列对比，我们会发现在职责划分上有一些不同点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt; — 数据交互逻辑被转移到了交互器&lt;strong&gt;Interactor&lt;/strong&gt;中，&lt;strong&gt;Entities&lt;/strong&gt;只有纯粹的数据结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller/Presenter/ViewModel&lt;/strong&gt;中的UI展现职责转移到了交互器&lt;strong&gt;Interactor&lt;/strong&gt;中，但它没有更改数据的能力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VIPER&lt;/strong&gt;是第一个明确提出地址导航职责应该由路由器&lt;strong&gt;Router&lt;/strong&gt;来解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;在iOS应用中找到一种合适的路由方式是一个挑战，&lt;strong&gt;MV(X)&lt;/strong&gt;系列模式都没有定位到这个问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面的&lt;strong&gt;VIPER&lt;/strong&gt;例子中没有涉及到模块之间的路由或交互，当然在&lt;strong&gt;MV(X)&lt;/strong&gt;系列模式中也根本没有涉及。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;import UIKit

struct Person { // Entity (usually more complex e.g. NSManagedObject)
    let firstName: String
    let lastName: String
}

struct GreetingData { // Transport data structure (not Entity)
    let greeting: String
    let subject: String
}

protocol GreetingProvider {
    func provideGreetingData()
}

protocol GreetingOutput: class {
    func receiveGreetingData(greetingData: GreetingData)
}

class GreetingInteractor : GreetingProvider {
    weak var output: GreetingOutput!
    
    func provideGreetingData() {
        let person = Person(firstName: &quot;David&quot;, lastName: &quot;Blaine&quot;) // usually comes from data access layer
        let subject = person.firstName + &quot; &quot; + person.lastName
        let greeting = GreetingData(greeting: &quot;Hello&quot;, subject: subject)
        self.output.receiveGreetingData(greeting)
    }
}

protocol GreetingViewEventHandler {
    func didTapShowGreetingButton()
}

protocol GreetingView: class {
    func setGreeting(greeting: String)
}

class GreetingPresenter : GreetingOutput, GreetingViewEventHandler {
    weak var view: GreetingView!
    var greetingProvider: GreetingProvider!
    
    func didTapShowGreetingButton() {
        self.greetingProvider.provideGreetingData()
    }
    
    func receiveGreetingData(greetingData: GreetingData) {
        let greeting = greetingData.greeting + &quot; &quot; + greetingData.subject
        self.view.setGreeting(greeting)
    }
}

class GreetingViewController : UIViewController, GreetingView {
    var eventHandler: GreetingViewEventHandler!
    let showGreetingButton = UIButton()
    let greetingLabel = UILabel()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.showGreetingButton.addTarget(self, action: &quot;didTapButton:&quot;, forControlEvents: .TouchUpInside)
    }
    
    func didTapButton(button: UIButton) {
        self.eventHandler.didTapShowGreetingButton()
    }
    
    func setGreeting(greeting: String) {
        self.greetingLabel.text = greeting
    }
    
    // layout code goes here
}
// Assembling of VIPER module, without Router
let view = GreetingViewController()
let presenter = GreetingPresenter()
let interactor = GreetingInteractor()
view.eventHandler = presenter
presenter.view = view
presenter.greetingProvider = interactor
interactor.output = presenter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们再来看看&lt;strong&gt;VIPER&lt;/strong&gt;的特征：
* 划分 - 毫无疑问，&lt;strong&gt;VIPER&lt;/strong&gt;在职责划分上是最好的。
* 可测试性 - 毫无悬念，好的职责划分必然有好的可测性。
* 易用性 - 由于上述两个特征你就可以猜测到代码维护性成本很高，你不得不编写大量的接口类来完成很小的职责。&lt;/p&gt;

&lt;h4&gt;总结&lt;/h4&gt;

&lt;p&gt;我们已经从头到尾地了解了几种架构模式，希望你能从中找到那些曾经困扰你很久的问题的答案。但我毫不怀疑，你已经意识到了没有什么银色子弹，选择什么样的架构设计是特定场景下权衡各种因素之后的结果。因此，在同一个app中就会出现混合架构设计。比如：一开始使用&lt;strong&gt;MVC&lt;/strong&gt;，然后你发现有一些特殊场景如果使用&lt;strong&gt;MVC&lt;/strong&gt;将会难以维护，这时你可以仅对这个场景使用&lt;strong&gt;MVVM&lt;/strong&gt;模式，没必要去重构那些&lt;strong&gt;MVC&lt;/strong&gt;架构执行的很好的模块。&lt;strong&gt;MV(X)&lt;/strong&gt;系列是互相兼容的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make everything as simple as possible, but not simpler. -- Albert Einstein&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 18 Apr 2016 00:00:00 +0800</pubDate>
        <link>https://github.com/zhangyinglong/DemonHunter//2016/iOS-%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E6%8F%AD%E7%A7%98-MVC-MVP-MVVM-%E5%92%8C-VIPER/</link>
        <guid isPermaLink="true">https://github.com/zhangyinglong/DemonHunter//2016/iOS-%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E6%8F%AD%E7%A7%98-MVC-MVP-MVVM-%E5%92%8C-VIPER/</guid>
        
        
      </item>
    
      <item>
        <title>Git工作流指南</title>
        <description>&lt;h3&gt;序言&lt;/h3&gt;

&lt;p&gt;Git不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应GIT提供的一些概念和特征。Git工作流有各式各样的用法，但也正因此使得在实际工作中如何上手使用变得很头大。这篇指南通过总览最常用的几种Git工作流让大家可以学习借鉴。在阅读的过程中请记住，工作流是作为方案指导而不是条例规定。在展示了各种工作流可能的用法后，你可以从不同的工作流中挑选或揉合出一个满足你自己需求的工作流。&lt;/p&gt;

&lt;h3&gt;集中式工作流&lt;/h3&gt;

&lt;p&gt;如果你的开发团队成员已经很熟悉Subversion，集中式工作流让你无需去适应一个全新流程就可以体验Git带来的收益。这个工作流也可以作为向更Git风格工作流迁移的友好过渡。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-69bacd15209ea362.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h3&gt;功能分支工作流&lt;/h3&gt;

&lt;p&gt;功能分支工作流以集中式工作流为基础，不同的是为各个新功能分配一个专门的分支来开发。一旦你玩转了集中式工作流，在开发过程中可以很简单地加上功能分支，用来鼓励开发者之间协作和简化交流。这样可以在把新功能集成到正式项目前，用Pull Requests的方式讨论变更。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-6988fa8bbfe7b9b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;功能分支工作流背后的核心思路是所有的功能开发应该在一个专门的分支，而不是在master分支上。这个隔离可以方便多个开发者在各自的功能上开发而不会弄乱主干代码。另外，也保证了master分支的代码一定不会是有问题的，极大有利于集成环境。
功能开发隔离也让pull requests工作流成功可能，pull requests工作流能为每个分支发起一个讨论，在分支合入正式项目之前，给其它开发者有表示赞同的机会。另外，如果你在功能开发中有问题卡住了，可以开一个pull requests来向同学们征求建议。这些做法的重点就是，pull requests让团队成员之间互相评论工作变成非常方便！&lt;/p&gt;

&lt;h3&gt;Pull Request工作流&lt;/h3&gt;

&lt;p&gt;Pull Requests是gitlab上方便开发者之间协作的功能。提供了一个用户友好的Web界面，在集成提交的变更到正式项目前可以对变更进行讨论。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-a1ac03ccb5cbd382.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;开发者向团队成员通知功能开发已经完成，Pull Requests是最简单的用法。开发者完成功能开发后，通过gitlab账号发起一个Pull Request。这样让涉及这个功能的所有人知道，要去做Code Review，bug fixed和合并到master分支。但是，Pull Request远不止一个简单的通知，而是为讨论提交的功能的一个专门论坛。如果变更有任何问题，团队成员反馈在Pull Request中，甚至push新的提交微调功能。所有的这些活动都直接跟踪在Pull Request中。&lt;/p&gt;

&lt;h3&gt;Gitflow工作流&lt;/h3&gt;

&lt;p&gt;Gitflow工作流通过为功能开发、发布准备和维护分配独立的分支，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-f8c9895dd1d92dbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Gitflow工作流定义了一个围绕项目发布的严格分支模型。虽然比功能分支工作流复杂几分，但提供了用于一个健壮的用于管理大型项目的框架，，尤其适合敏捷开发管理模式。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-9b29adba17c04701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Gitflow工作流没有用超出功能分支工作流的概念和命令，而是为不同的分支分配一个很明确的角色，并定义分支之间如何和什么时候进行交互。除了使用功能分支，在做准备、维护和记录发布也使用各自的分支。当然你可以用上功能分支工作流所有的好处：Pull Requests、隔离实验性开发和更高效的协作。&lt;/p&gt;

&lt;h3&gt;Forking工作流&lt;/h3&gt;

&lt;p&gt;Forking工作流是分布式工作流，充分利用了Git在分支和克隆上的优势。可以安全可靠地管理大团队的开发者（developer），并能接受不信任贡献者（contributor）的提交。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1200910-8bba9fd69d26fa7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Forking工作流和前面讨论的几种工作流有根本的不同。这种工作流不是使用单个服务端仓库作为『中央』代码基线，而让各个开发者都有一个服务端仓库。这意味着各个代码贡献者有2个Git仓库而不是1个：一个本地私有的，另一个服务端公开的。Forking工作流的一个主要优势是，贡献的代码可以被集成，而不需要所有人都能push代码到仅有的中央仓库中。开发者push到自己的服务端仓库，而只有项目维护者才能push到正式仓库。这样项目维护者可以接受任何开发者的提交，但无需给他正式代码库的写权限。效果就是一个分布式的工作流，能为大型、自发性的团队（包括了不受信的第三方）提供灵活的方式来安全的协作。也让这个工作流成为开源项目的理想工作流。&lt;/p&gt;

&lt;p&gt;参考文献： 
1、&lt;a href=&quot;http://blog.jobbole.com/76843/&quot;&gt;Git工作流指南&lt;/a&gt; 
2、&lt;a href=&quot;https://www.atlassian.com/git/tutorials/comparing-workflows/&quot;&gt;Comparing Workflows&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Apr 2016 00:00:00 +0800</pubDate>
        <link>https://github.com/zhangyinglong/DemonHunter//2016/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%87%E5%8D%97/</link>
        <guid isPermaLink="true">https://github.com/zhangyinglong/DemonHunter//2016/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E6%8C%87%E5%8D%97/</guid>
        
        
      </item>
    
      <item>
        <title>Cocoapods私有库配置笔记</title>
        <description>&lt;p&gt;&lt;code&gt;CocoaPods&lt;/code&gt;是一个iOS，Mac OS下强大的依赖包工具，不仅用来管理第三方开源代码的项目代码，您也可以通过配置公共组件的私有pods库，来管理整个项目中的公共组件。&lt;strong&gt;通过下面几个步骤，您可以为项目创建私有pods库&lt;/strong&gt;。&lt;/p&gt;

&lt;h3&gt;1. 创建私有Spec仓库&lt;/h3&gt;

&lt;p&gt;为了管理您的私有&lt;code&gt;pods&lt;/code&gt;库，建议创建一个自己的&lt;code&gt;Spec&lt;/code&gt;仓库。这个&lt;code&gt;Spec&lt;/code&gt;仓库包含了所有将要访问到的&lt;code&gt;pods&lt;/code&gt;库。您不需要从&lt;code&gt;CocoaPods/Specs&lt;/code&gt;检出分支，只需要保证团队里所有人都有这个&lt;code&gt;Spec&lt;/code&gt;仓库（不公开的）的访问权限。
（通常&lt;code&gt;CocoaPods&lt;/code&gt;使用中都会包含公开的和私有库，因此&lt;code&gt;Spec&lt;/code&gt;仓库也可以直接使用默认公开库的路径地址）&lt;/p&gt;

&lt;h3&gt;2. 添加私有Spec仓库到CocoaPods默认的路径&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;pod repo add &amp;lt;REPO_NAME&amp;gt; &amp;lt;SOURCE_URL&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果打算创建本地的&lt;code&gt;pods&lt;/code&gt;仓库，您还需要推送至&lt;code&gt;&amp;lt;SOURCE_URL&amp;gt;&lt;/code&gt;源地址
检测您的&lt;code&gt;Spec&lt;/code&gt;仓库是否创建成功： &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;cd ~/.cocoapods/repos/&amp;lt;REPO_NAME&amp;gt; // 不同版本的CocoaPods，路径可能不一样
pod repo lint .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;

&lt;h3&gt;3. 添加私有Spec仓库的Podspec配置文件&lt;/h3&gt;

&lt;p&gt;确保您的源代码已经打好版本tag，然后执行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;pod repo push &amp;lt;REPO_NAME&amp;gt; &amp;lt;SPEC_NAME&amp;gt;.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这将会执行&lt;code&gt;pod spec lint&lt;/code&gt;，注意过程中的细节，&lt;code&gt;Spec&lt;/code&gt;仓库目录格式应该是&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;.
├── Specs
    └── [SPEC_NAME]
        └── [VERSION]
            └── [SPEC_NAME].podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;至此，您的私有&lt;code&gt;pods&lt;/code&gt;仓库已经可以通过&lt;code&gt;Podfile&lt;/code&gt;文件使用了，还需要在在&lt;code&gt;Podfile&lt;/code&gt;中指定私有库的源地址，如下：&lt;/h5&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;source &#39;&amp;lt;URL_TO_REPOSITORY&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;举个例子&lt;/h2&gt;

&lt;h3&gt;1. 创建私有代码仓库&lt;/h3&gt;

&lt;p&gt;创建一个代码仓库，可以托管在Github，或您自己的git服务器&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ cd ~/Desktop
$ mkdir EGKit.git
$ cd EGKit.git
$ git init --bare
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(The rest of this example uses the repo at &lt;a href=&quot;https://github.com/zhangyinglong/EGKit.git&quot;&gt;https://github.com/zhangyinglong/EGKit.git&lt;/a&gt;)&lt;/p&gt;

&lt;h3&gt;2. 添加本地私有库的CocoaPods安装源&lt;/h3&gt;

&lt;p&gt;使用你的代码仓库地址，作为CocoaPods安装源&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ pod repo add EGKit https://github.com/zhangyinglong/EGKit.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入本地CocoaPods安装源路径（&lt;code&gt;CocoaPods&lt;/code&gt;版本不同路径可能也不同），检查是否安装成功&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;$ cd ~/.cocoapods/repos/EGKit
$ pod repo lint .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 为私有库添加Podspec配置文件&lt;/h3&gt;

&lt;p&gt;创建Podspec配置文件&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;cd ~/Desktop
touch EGKit.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编辑配置文件内容 &lt;code&gt;EGKit.podspec&lt;/code&gt; 。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;#
# Be sure to run `pod lib lint EGKit.podspec&#39; to ensure this is a
# valid spec before submitting.
#
# Any lines starting with a # are optional, but their use is encouraged
# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html
#

Pod::Spec.new do |s|
  s.name             = &quot;EGKit&quot;
  s.version          = &quot;0.1.0&quot;
  s.summary          = &quot;A demo of EGKit.&quot;

# This description is used to generate tags and improve search results.
#   * Think: What does it do? Why did you write it? What is the focus?
#   * Try to keep it short, snappy and to the point.
#   * Write the description between the DESC delimiters below.
#   * Finally, don&#39;t worry about the indent, CocoaPods strips it!  
  s.description      = &amp;lt;&amp;lt;-DESC
                        A test demo of EGKit.
                       DESC

  s.homepage         = &quot;https://github.com/zhangyinglong/EGKit&quot;
  # s.screenshots     = &quot;www.example.com/screenshots_1&quot;, &quot;www.example.com/screenshots_2&quot;
  s.license          = &#39;MIT&#39;
  s.author           = { &quot;zhangyinglong&quot; =&amp;gt; &quot;zyl04401@gmail.com&quot; }
  s.source           = { :git =&amp;gt; &quot;https://github.com/zhangyinglong/EGKit.git&quot;, :tag =&amp;gt; s.version.to_s }
  # s.social_media_url = &#39;https://twitter.com/&amp;lt;TWITTER_USERNAME&amp;gt;&#39;

  s.platform     = :ios, &#39;7.0&#39;
  s.requires_arc = true

  s.source_files = &#39;Pod/Classes/**/*&#39;
  #s.resource_bundles = {
  #  &#39;EGKit&#39; =&amp;gt; [&#39;Pod/Assets/*.png&#39;]
  #}

  # s.public_header_files = &#39;Pod/Classes/**/*.h&#39;
  # s.frameworks = &#39;UIKit&#39;, &#39;MapKit&#39;
  # s.dependency &#39;AFNetworking&#39;, &#39;~&amp;gt; 2.3&#39;
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存&lt;code&gt;EGKit.podspec&lt;/code&gt; 配置文件，并添加到本地&lt;code&gt;pods&lt;/code&gt;库中&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;pod repo push EGKit ~/Desktop/EGKit.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如您的Podspec配置成功，它将会自动添加到本地&lt;code&gt;pods&lt;/code&gt;库中，目录结构如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;.
├── Specs
    └── EGKit
        └── 0.1.0
            └── EGKit.podspec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4. 如何删除私有库&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;pod repo remove EGKit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考文献：&lt;a href=&quot;http://guides.cocoapods.org/making/private-cocoapods.html&quot;&gt;http://guides.cocoapods.org/making/private-cocoapods.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Apr 2016 00:00:00 +0800</pubDate>
        <link>https://github.com/zhangyinglong/DemonHunter//2016/CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">https://github.com/zhangyinglong/DemonHunter//2016/CocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/</guid>
        
        
      </item>
    
  </channel>
</rss>
